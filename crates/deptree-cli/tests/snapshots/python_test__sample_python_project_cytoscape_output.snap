---
source: tests/python_test.rs
expression: cytoscape_output
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependency Graph - Cytoscape.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.33.1/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
    <!-- Layout Extensions -->
    <script src="https://unpkg.com/cose-base@1.0.0/cose-base.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-cose-bilkent@4.1.0/cytoscape-cose-bilkent.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webcola@3.4.0/WebCola/cola.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-cola@2.5.1/cytoscape-cola.min.js"></script>
    <script src="https://unpkg.com/elkjs@0.9.0/lib/elk.bundled.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-elk@2.2.0/dist/cytoscape-elk.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #controls {
            background: #f5f5f5;
            padding: 12px;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        #content-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #filter-panel {
            width: 280px;
            background: #f9f9f9;
            border-right: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
            flex-shrink: 0;
        }

        #filter-panel.collapsed {
            margin-left: -280px;
        }

        #cy-container {
            flex: 1;
            position: relative;
            background: #ffffff;
        }

        #cy {
            width: 100%;
            height: 100%;
        }

        button {
            padding: 8px 16px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #e9e9e9;
        }

        button:active {
            background: #d9d9d9;
        }

        button.primary {
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        button.primary:hover {
            background: #1565c0;
        }

        #toggle-filters {
            font-size: 18px;
            padding: 8px 12px;
            font-weight: bold;
        }

        #info {
            font-size: 14px;
            color: #666;
            margin-left: auto;
        }

        .filter-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        .filter-section:last-child {
            border-bottom: none;
        }

        .filter-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .filter-section label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
        }

        .filter-section input[type="checkbox"] {
            margin-right: 6px;
        }

        .filter-section input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        .filter-section small {
            display: block;
            margin-top: 4px;
            color: #666;
            font-size: 11px;
        }

        #distance-slider {
            width: 100%;
            margin: 8px 0;
        }

        #distance-display {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .module-chips {
            min-height: 30px;
            margin-bottom: 8px;
        }

        .module-chip {
            display: inline-block;
            background: #1976d2;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            margin: 2px;
            font-size: 11px;
        }

        .module-chip .remove {
            margin-left: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .module-chip .remove:hover {
            color: #ffcccc;
        }

        .module-dropdown {
            position: relative;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 4px;
        }

        .module-dropdown input {
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }

        .module-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .module-item {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .module-item:hover {
            background: #f5f5f5;
        }

        .small-btn {
            font-size: 12px;
            padding: 4px 8px;
            width: 100%;
        }

        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 150px;
        }

        .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid #f0f0f0;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        /* Layout Settings Styles */
        .layout-setting {
            margin: 8px 0;
        }

        .layout-setting label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #555;
        }

        .layout-setting select,
        .layout-setting input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        .layout-setting input[type="checkbox"] {
            margin-left: 0;
            cursor: pointer;
        }

        .advanced-settings-section {
            margin-top: 12px;
        }

        .advanced-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            color: #555;
            user-select: none;
        }

        .advanced-toggle:hover {
            background: #e5e5e5;
        }

        .toggle-icon {
            font-size: 10px;
            width: 12px;
        }

        .advanced-settings-content {
            margin-top: 8px;
            padding-left: 8px;
        }

        #apply-layout-btn {
            width: 100%;
            margin-top: 10px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 13px;
            z-index: 1000;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #999;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="controls">
            <button id="toggle-filters" title="Toggle Filters">≡</button>
            <button onclick="fitGraph()">Fit to Screen</button>
            <button onclick="resetZoom()">Reset Zoom</button>
            <button onclick="centerGraph()">Center</button>
            <button onclick="exportPNG()">Export as PNG</button>
            <div id="info"></div>
        </div>

        <div id="content-container">
            <div id="filter-panel" class="collapsed">
                <div class="filter-section">
                    <h3>Display Options</h3>
                    <label><input type="checkbox" id="filter-orphans"> Show Orphan Nodes</label>
                    <label><input type="checkbox" id="filter-namespaces"> Show Namespace Packages</label>
                    <label><input type="checkbox" id="filter-highlighted-only"> Highlighted Only</label>
                </div>

                <div class="filter-section">
                    <h3>Distance Limit</h3>
                    <input type="range" id="distance-slider" min="0" max="10" step="1" value="0">
                    <div id="distance-display">All Distances</div>
                </div>

                <div class="filter-section">
                    <h3>Upstream Dependencies</h3>
                    <div id="upstream-selector">
                        <div class="module-chips" id="upstream-chips"></div>
                    </div>
                    <button id="add-upstream" class="small-btn">+ Add Module</button>
                </div>

                <div class="filter-section">
                    <h3>Downstream Dependencies</h3>
                    <div id="downstream-selector">
                        <div class="module-chips" id="downstream-chips"></div>
                    </div>
                    <button id="add-downstream" class="small-btn">+ Add Module</button>
                </div>

                <div class="filter-section">
                    <h3>Exclude Scripts</h3>
                    <input type="text" id="exclude-patterns" placeholder="*old*, test_*">
                    <small>Supports wildcards: *prefix, suffix*, *substring*</small>
                </div>

                <div class="filter-section">
                    <h3>Layout Algorithm</h3>
                    <label>
                        <select id="layout-select">
                            <optgroup label="Built-in Layouts">
                                <option value="dagre">Dagre (Hierarchical)</option>
                                <option value="cose">CoSE (Force-directed)</option>
                                <option value="breadthfirst">Breadthfirst (Tree)</option>
                                <option value="circle">Circle</option>
                                <option value="grid">Grid</option>
                                <option value="concentric">Concentric</option>
                            </optgroup>
                            <optgroup label="Extension Layouts">
                                <option value="cose-bilkent">CoSE-Bilkent (Enhanced)</option>
                                <option value="cola">Cola (Constraint-based)</option>
                                <option value="elk">ELK (Advanced)</option>
                            </optgroup>
                        </select>
                    </label>
                    <small id="layout-description" style="display: block; margin-top: 6px; color: #666;">
                        Hierarchical directed acyclic graph
                    </small>

                    <div id="layout-settings-container" style="margin-top: 12px;">
                        <!-- Settings will be dynamically rendered here -->
                    </div>

                    <button id="apply-layout-btn" class="primary">Apply Layout</button>
                </div>

                <div class="filter-section">
                    <button id="reset-filters">Reset to Original</button>
                    <button id="apply-filters" class="primary">Apply Filters</button>
                </div>
            </div>

            <div id="cy-container">
                <div id="cy"></div>

                <div class="legend">
                    <div class="legend-title">Legend</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #90caf9; border-radius: 50%;"></div>
                        <span>Module</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #a5d6a7;"></div>
                        <span>Script</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffcc80; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);"></div>
                        <span>Namespace Package</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #bbdefb; border: 2px solid #1976d2;"></div>
                        <span>Highlighted</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== Filter Utility Functions =====

        // Pattern matching with wildcard support
        function matchesPattern(nodeName, pattern) {
            if (!pattern) return false;

            if (!pattern.includes('*')) {
                // No wildcard - check if pattern is substring
                return nodeName.includes(pattern);
            }

            if (pattern.startsWith('*') && pattern.endsWith('*')) {
                // *substring* - contains check
                return nodeName.includes(pattern.slice(1, -1));
            } else if (pattern.startsWith('*')) {
                // *suffix - endsWith check
                return nodeName.endsWith(pattern.slice(1));
            } else if (pattern.endsWith('*')) {
                // prefix* - startsWith check
                return nodeName.startsWith(pattern.slice(0, -1));
            }

            return false;
        }

        // Get all node data from Cytoscape
        function getAllNodes() {
            return cy.nodes().map(node => ({
                id: node.id(),
                data: node.data(),
                element: node
            }));
        }

        // Get all edges as source-target pairs
        function getAllEdges() {
            return cy.edges().map(edge => ({
                source: edge.source().id(),
                target: edge.target().id(),
                element: edge
            }));
        }

        // ===== Layout Configurations =====

        const LAYOUT_CONFIGS = {
            dagre: {
                name: 'Dagre',
                description: 'Hierarchical directed acyclic graph',
                category: 'built-in',
                settings: {
                    key: {
                        rankDir: {
                            label: 'Direction',
                            type: 'select',
                            options: [
                                { value: 'TB', label: 'Top to Bottom' },
                                { value: 'LR', label: 'Left to Right' },
                                { value: 'BT', label: 'Bottom to Top' },
                                { value: 'RL', label: 'Right to Left' }
                            ],
                            default: 'LR'
                        },
                        nodeSep: {
                            label: 'Node Separation',
                            type: 'number',
                            min: 10,
                            max: 200,
                            default: 50,
                            step: 10
                        }
                    },
                    advanced: {
                        rankSep: {
                            label: 'Rank Separation',
                            type: 'number',
                            min: 20,
                            max: 300,
                            default: 100,
                            step: 10
                        },
                        padding: {
                            label: 'Padding',
                            type: 'number',
                            min: 0,
                            max: 100,
                            default: 30,
                            step: 5
                        }
                    }
                }
            },
            cose: {
                name: 'CoSE',
                description: 'Force-directed spring embedder',
                category: 'built-in',
                settings: {
                    key: {
                        nodeRepulsion: {
                            label: 'Node Repulsion',
                            type: 'number',
                            min: 100,
                            max: 10000,
                            default: 400000,
                            step: 1000
                        },
                        idealEdgeLength: {
                            label: 'Edge Length',
                            type: 'number',
                            min: 10,
                            max: 500,
                            default: 100,
                            step: 10
                        }
                    },
                    advanced: {
                        gravity: {
                            label: 'Gravity',
                            type: 'number',
                            min: 0,
                            max: 10,
                            default: 1,
                            step: 0.1
                        },
                        numIter: {
                            label: 'Iterations',
                            type: 'number',
                            min: 100,
                            max: 5000,
                            default: 1000,
                            step: 100
                        }
                    }
                }
            },
            breadthfirst: {
                name: 'Breadthfirst',
                description: 'Tree layout from roots',
                category: 'built-in',
                settings: {
                    key: {
                        directed: {
                            label: 'Use Edge Direction',
                            type: 'checkbox',
                            default: true
                        },
                        circle: {
                            label: 'Circular Layout',
                            type: 'checkbox',
                            default: false
                        }
                    },
                    advanced: {
                        spacingFactor: {
                            label: 'Spacing Factor',
                            type: 'number',
                            min: 0.5,
                            max: 3,
                            default: 1.75,
                            step: 0.25
                        }
                    }
                }
            },
            circle: {
                name: 'Circle',
                description: 'Nodes in a circle',
                category: 'built-in',
                settings: {
                    key: {
                        radius: {
                            label: 'Radius (leave empty for auto)',
                            type: 'number',
                            min: 50,
                            max: 1000,
                            default: null,
                            step: 50,
                            nullable: true
                        }
                    },
                    advanced: {
                        startAngle: {
                            label: 'Start Angle (radians)',
                            type: 'number',
                            min: 0,
                            max: 6.28,
                            default: 3.14159,
                            step: 0.1
                        },
                        sweep: {
                            label: 'Sweep (radians)',
                            type: 'number',
                            min: 0.1,
                            max: 6.28,
                            default: 6.28318,
                            step: 0.1
                        }
                    }
                }
            },
            grid: {
                name: 'Grid',
                description: 'Regular grid arrangement',
                category: 'built-in',
                settings: {
                    key: {
                        avoidOverlap: {
                            label: 'Avoid Overlap',
                            type: 'checkbox',
                            default: true
                        }
                    },
                    advanced: {
                        rows: {
                            label: 'Rows (leave empty for auto)',
                            type: 'number',
                            min: 1,
                            max: 50,
                            default: null,
                            step: 1,
                            nullable: true
                        },
                        cols: {
                            label: 'Columns (leave empty for auto)',
                            type: 'number',
                            min: 1,
                            max: 50,
                            default: null,
                            step: 1,
                            nullable: true
                        }
                    }
                }
            },
            concentric: {
                name: 'Concentric',
                description: 'Concentric circles by importance',
                category: 'built-in',
                settings: {
                    key: {
                        minNodeSpacing: {
                            label: 'Min Node Spacing',
                            type: 'number',
                            min: 10,
                            max: 200,
                            default: 50,
                            step: 10
                        }
                    },
                    advanced: {
                        startAngle: {
                            label: 'Start Angle (radians)',
                            type: 'number',
                            min: 0,
                            max: 6.28,
                            default: 3.14159,
                            step: 0.1
                        }
                    }
                }
            },
            'cose-bilkent': {
                name: 'CoSE-Bilkent',
                description: 'Enhanced force-directed (better quality)',
                category: 'extension',
                settings: {
                    key: {
                        nodeRepulsion: {
                            label: 'Node Repulsion',
                            type: 'number',
                            min: 100,
                            max: 10000,
                            default: 4500,
                            step: 100
                        },
                        idealEdgeLength: {
                            label: 'Edge Length',
                            type: 'number',
                            min: 10,
                            max: 500,
                            default: 100,
                            step: 10
                        }
                    },
                    advanced: {
                        quality: {
                            label: 'Quality',
                            type: 'select',
                            options: [
                                { value: 'default', label: 'Default' },
                                { value: 'draft', label: 'Draft (faster)' },
                                { value: 'proof', label: 'Proof (better quality)' }
                            ],
                            default: 'default'
                        },
                        gravity: {
                            label: 'Gravity',
                            type: 'number',
                            min: 0,
                            max: 1,
                            default: 0.25,
                            step: 0.05
                        }
                    }
                }
            },
            cola: {
                name: 'Cola',
                description: 'Constraint-based force-directed',
                category: 'extension',
                settings: {
                    key: {
                        edgeLength: {
                            label: 'Edge Length',
                            type: 'number',
                            min: 10,
                            max: 500,
                            default: 100,
                            step: 10
                        },
                        nodeSpacing: {
                            label: 'Node Spacing',
                            type: 'number',
                            min: 5,
                            max: 100,
                            default: 20,
                            step: 5
                        }
                    },
                    advanced: {
                        convergenceThreshold: {
                            label: 'Convergence Threshold',
                            type: 'number',
                            min: 0.001,
                            max: 0.1,
                            default: 0.01,
                            step: 0.001
                        },
                        maxSimulationTime: {
                            label: 'Max Time (ms)',
                            type: 'number',
                            min: 1000,
                            max: 10000,
                            default: 4000,
                            step: 500
                        }
                    }
                }
            },
            elk: {
                name: 'ELK',
                description: 'Eclipse Layout Kernel (advanced)',
                category: 'extension',
                settings: {
                    key: {
                        algorithm: {
                            label: 'Algorithm',
                            type: 'select',
                            options: [
                                { value: 'layered', label: 'Layered (hierarchical)' },
                                { value: 'force', label: 'Force' },
                                { value: 'stress', label: 'Stress' },
                                { value: 'mrtree', label: 'MR Tree' }
                            ],
                            default: 'layered'
                        },
                        'elk.direction': {
                            label: 'Direction',
                            type: 'select',
                            options: [
                                { value: 'DOWN', label: 'Top to Bottom' },
                                { value: 'RIGHT', label: 'Left to Right' },
                                { value: 'UP', label: 'Bottom to Top' },
                                { value: 'LEFT', label: 'Right to Left' }
                            ],
                            default: 'RIGHT'
                        }
                    },
                    advanced: {
                        'elk.spacing.nodeNode': {
                            label: 'Node Spacing',
                            type: 'number',
                            min: 10,
                            max: 200,
                            default: 80,
                            step: 10
                        },
                        'elk.layered.spacing.nodeNodeBetweenLayers': {
                            label: 'Layer Spacing',
                            type: 'number',
                            min: 10,
                            max: 200,
                            default: 100,
                            step: 10
                        }
                    }
                }
            }
        };

        // ===== Filter State Class =====

        class FilterState {
            constructor() {
                this.showOrphans = true;
                this.showNamespaces = true;
                this.excludePatterns = [];
                this.upstreamRoots = new Set();
                this.downstreamRoots = new Set();
                this.maxDistance = null;
                this.highlightedOnly = false;
            }

            reset() {
                this.showOrphans = true;
                this.showNamespaces = true;
                this.excludePatterns = [];
                this.upstreamRoots = new Set();
                this.downstreamRoots = new Set();
                this.maxDistance = null;
                this.highlightedOnly = false;
            }

            computeVisibleNodes() {
                let nodes = getAllNodes();
                const edges = getAllEdges();

                // 1. Filter orphans
                if (!this.showOrphans) {
                    nodes = nodes.filter(n => !n.data.is_orphan);
                }

                // 2. Filter namespace packages
                if (!this.showNamespaces) {
                    nodes = nodes.filter(n => n.data.type !== 'namespace');
                }

                // 3. Exclude scripts by pattern
                if (this.excludePatterns.length > 0) {
                    nodes = nodes.filter(n => {
                        return !this.excludePatterns.some(pattern =>
                            matchesPattern(n.id, pattern)
                        );
                    });
                }

                // 4. Distance-based filtering (upstream/downstream)
                if (this.upstreamRoots.size > 0 || this.downstreamRoots.size > 0) {
                    nodes = this.filterByDistance(nodes);
                }

                // 5. Highlighted only mode
                if (this.highlightedOnly) {
                    nodes = nodes.filter(n => n.data.highlighted);
                }

                return new Set(nodes.map(n => n.id));
            }

            filterByDistance(nodes) {
                const visible = new Set();

                // Process upstream roots
                for (const root of this.upstreamRoots) {
                    for (const node of nodes) {
                        const distances = node.data.all_distances || {};
                        const dist = distances[root];
                        if (dist !== undefined &&
                            (this.maxDistance === null || dist <= this.maxDistance)) {
                            visible.add(node.id);
                        }
                    }
                }

                // Process downstream roots - need to use reverse distances
                for (const root of this.downstreamRoots) {
                    for (const node of nodes) {
                        const distances = node.data.all_distances || {};
                        // Check if root can reach this node
                        const rootNode = cy.getElementById(root);
                        if (rootNode.length > 0) {
                            const rootDistances = rootNode.data('all_distances') || {};
                            const dist = rootDistances[node.id];
                            if (dist !== undefined &&
                                (this.maxDistance === null || dist <= this.maxDistance)) {
                                visible.add(node.id);
                            }
                        }
                    }
                }

                // If both upstream and downstream specified, take intersection
                if (this.upstreamRoots.size > 0 && this.downstreamRoots.size > 0) {
                    const upstreamNodes = new Set();
                    const downstreamNodes = new Set();

                    for (const root of this.upstreamRoots) {
                        for (const node of nodes) {
                            const distances = node.data.all_distances || {};
                            const dist = distances[root];
                            if (dist !== undefined &&
                                (this.maxDistance === null || dist <= this.maxDistance)) {
                                upstreamNodes.add(node.id);
                            }
                        }
                    }

                    for (const root of this.downstreamRoots) {
                        for (const node of nodes) {
                            const rootNode = cy.getElementById(root);
                            if (rootNode.length > 0) {
                                const rootDistances = rootNode.data('all_distances') || {};
                                const dist = rootDistances[node.id];
                                if (dist !== undefined &&
                                    (this.maxDistance === null || dist <= this.maxDistance)) {
                                    downstreamNodes.add(node.id);
                                }
                            }
                        }
                    }

                    // Return intersection
                    return nodes.filter(n => upstreamNodes.has(n.id) && downstreamNodes.has(n.id));
                }

                // Return union if only one type specified
                return nodes.filter(n => visible.has(n.id));
            }
        }

        // ===== LayoutManager Class =====

        class LayoutManager {
            constructor() {
                this.currentLayout = 'dagre';  // Default layout
                this.settings = {};  // Current settings for each layout
                this.advancedExpanded = false;

                // Initialize default settings for all layouts
                for (const [layoutName, config] of Object.entries(LAYOUT_CONFIGS)) {
                    this.settings[layoutName] = {};

                    // Load key settings defaults
                    for (const [settingName, settingConfig] of Object.entries(config.settings.key)) {
                        this.settings[layoutName][settingName] = settingConfig.default;
                    }

                    // Load advanced settings defaults
                    for (const [settingName, settingConfig] of Object.entries(config.settings.advanced)) {
                        this.settings[layoutName][settingName] = settingConfig.default;
                    }
                }
            }

            setLayout(layoutName) {
                if (LAYOUT_CONFIGS[layoutName]) {
                    this.currentLayout = layoutName;
                    this.renderSettingsUI();
                }
            }

            setSetting(settingName, value) {
                this.settings[this.currentLayout][settingName] = value;
            }

            getLayoutOptions() {
                const config = LAYOUT_CONFIGS[this.currentLayout];
                const options = {
                    name: this.currentLayout,
                    animate: false,  // No animation for manual apply
                    animationDuration: 0
                };

                // Merge current settings into options
                for (const [key, value] of Object.entries(this.settings[this.currentLayout])) {
                    // Skip null values (for nullable settings)
                    if (value !== null) {
                        options[key] = value;
                    }
                }

                return options;
            }

            getLayoutOptionsWithAnimation() {
                const options = this.getLayoutOptions();
                options.animate = true;
                options.animationDuration = 500;
                return options;
            }

            renderSettingsUI() {
                const config = LAYOUT_CONFIGS[this.currentLayout];
                const container = document.getElementById('layout-settings-container');
                container.innerHTML = '';

                // Render key settings
                for (const [settingName, settingConfig] of Object.entries(config.settings.key)) {
                    const settingEl = this.createSettingControl(settingName, settingConfig);
                    container.appendChild(settingEl);
                }

                // Render advanced settings in expandable section
                const advancedSection = document.createElement('div');
                advancedSection.className = 'advanced-settings-section';

                const advancedToggle = document.createElement('div');
                advancedToggle.className = 'advanced-toggle';
                advancedToggle.innerHTML = `
                    <span class="toggle-icon">${this.advancedExpanded ? '▼' : '▶'}</span>
                    <span>Advanced Settings</span>
                `;
                advancedToggle.addEventListener('click', () => {
                    this.advancedExpanded = !this.advancedExpanded;
                    advancedContent.style.display = this.advancedExpanded ? 'block' : 'none';
                    advancedToggle.querySelector('.toggle-icon').textContent = this.advancedExpanded ? '▼' : '▶';
                });

                const advancedContent = document.createElement('div');
                advancedContent.className = 'advanced-settings-content';
                advancedContent.style.display = this.advancedExpanded ? 'block' : 'none';

                for (const [settingName, settingConfig] of Object.entries(config.settings.advanced)) {
                    const settingEl = this.createSettingControl(settingName, settingConfig);
                    advancedContent.appendChild(settingEl);
                }

                advancedSection.appendChild(advancedToggle);
                advancedSection.appendChild(advancedContent);
                container.appendChild(advancedSection);
            }

            createSettingControl(settingName, settingConfig) {
                const wrapper = document.createElement('div');
                wrapper.className = 'layout-setting';

                const label = document.createElement('label');
                label.textContent = settingConfig.label;
                wrapper.appendChild(label);

                let input;

                switch (settingConfig.type) {
                    case 'select':
                        input = document.createElement('select');
                        for (const option of settingConfig.options) {
                            const optEl = document.createElement('option');
                            optEl.value = option.value;
                            optEl.textContent = option.label;
                            input.appendChild(optEl);
                        }
                        input.value = this.settings[this.currentLayout][settingName];
                        input.addEventListener('change', (e) => {
                            this.setSetting(settingName, e.target.value);
                        });
                        break;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.min = settingConfig.min;
                        input.max = settingConfig.max;
                        input.step = settingConfig.step;
                        input.value = this.settings[this.currentLayout][settingName] ?? '';
                        input.placeholder = settingConfig.nullable ? 'Auto' : '';
                        input.addEventListener('input', (e) => {
                            const value = e.target.value === '' ? null : parseFloat(e.target.value);
                            this.setSetting(settingName, value);
                        });
                        break;

                    case 'checkbox':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = this.settings[this.currentLayout][settingName];
                        input.addEventListener('change', (e) => {
                            this.setSetting(settingName, e.target.checked);
                        });
                        break;
                }

                wrapper.appendChild(input);
                return wrapper;
            }
        }

        // Create global filter state
        const filterState = new FilterState();

        // Create global layout manager
        const layoutManager = new LayoutManager();

        // ===== Layout Application Function =====

        function applyCurrentLayout(withAnimation = true) {
            const options = withAnimation
                ? layoutManager.getLayoutOptionsWithAnimation()
                : layoutManager.getLayoutOptions();

            const layout = cy.layout(options);
            layout.run();
        }

        // ===== Apply Filters Function =====

        function applyFilters() {
            const visibleIds = filterState.computeVisibleNodes();

            // Update node visibility
            cy.nodes().forEach(node => {
                if (visibleIds.has(node.id())) {
                    node.style('display', 'element');
                } else {
                    node.style('display', 'none');
                }
            });

            // Update edge visibility - only show edges where both endpoints are visible
            cy.edges().forEach(edge => {
                const sourceVisible = visibleIds.has(edge.source().id());
                const targetVisible = visibleIds.has(edge.target().id());

                if (sourceVisible && targetVisible) {
                    edge.style('display', 'element');
                } else {
                    edge.style('display', 'none');
                }
            });

            // Re-run layout with current layout manager settings
            applyCurrentLayout(true);
        }

        // ===== Panel Toggle =====

        document.getElementById('toggle-filters').addEventListener('click', () => {
            const panel = document.getElementById('filter-panel');
            panel.classList.toggle('collapsed');

            // Resize graph after animation
            setTimeout(() => cy.resize(), 300);
        });

        // ===== Layout UI Event Handlers =====

        document.getElementById('layout-select').addEventListener('change', (e) => {
            const selectedLayout = e.target.value;
            layoutManager.setLayout(selectedLayout);

            // Update description
            const config = LAYOUT_CONFIGS[selectedLayout];
            document.getElementById('layout-description').textContent = config.description;
        });

        document.getElementById('apply-layout-btn').addEventListener('click', () => {
            applyCurrentLayout();
        });

        // Initialize layout UI
        layoutManager.renderSettingsUI();
        document.getElementById('layout-select').value = 'dagre';

        // Register layout extensions with Cytoscape
        if (typeof cytoscape !== 'undefined') {
            // Register cose-bilkent
            if (typeof cytoscapeCoseBilkent !== 'undefined') {
                cytoscape.use(cytoscapeCoseBilkent);
            }

            // Register cola
            if (typeof cytoscapeCola !== 'undefined') {
                cytoscape.use(cytoscapeCola);
            }

            // Register elk
            if (typeof cytoscapeElk !== 'undefined') {
                cytoscape.use(cytoscapeElk);
            }
        }

        // Initialize Cytoscape
        const cy = cytoscape({
            container: document.getElementById('cy'),

            elements: [
    { "data": { "id": "main", "label": "main", "type": "module"  , "is_orphan": false, "all_distances": { "main": 0, "pkg_a": 1, "pkg_b.module_b": 1 } } },
    { "data": { "id": "pkg_a", "label": "pkg_a", "type": "module"  , "is_orphan": false, "all_distances": { "pkg_a": 0 } } },
    { "data": { "id": "pkg_a.module_a", "label": "pkg_a.module_a", "type": "module"  , "is_orphan": false, "all_distances": { "pkg_a.module_a": 0, "pkg_b": 1 } } },
    { "data": { "id": "pkg_b", "label": "pkg_b", "type": "module"  , "is_orphan": false, "all_distances": { "pkg_b": 0 } } },
    { "data": { "id": "pkg_b.module_b", "label": "pkg_b.module_b", "type": "module"  , "is_orphan": false, "all_distances": { "pkg_b.module_b": 0 } } },
    { "data": { "source": "main", "target": "pkg_a" } },
    { "data": { "source": "main", "target": "pkg_b.module_b" } },
    { "data": { "source": "pkg_a.module_a", "target": "pkg_b" } }
            ],

            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '12px',
                        'background-color': '#90caf9',
                        'border-width': 1,
                        'border-color': '#1976d2',
                        'width': 'label',
                        'height': 'label',
                        'padding': '10px',
                        'shape': 'ellipse',
                        'text-wrap': 'wrap',
                        'text-max-width': '150px'
                    }
                },
                {
                    selector: 'node[type="script"]',
                    style: {
                        'shape': 'rectangle',
                        'background-color': '#a5d6a7',
                        'border-color': '#388e3c'
                    }
                },
                {
                    selector: 'node[type="namespace"]',
                    style: {
                        'shape': 'hexagon',
                        'background-color': '#ffcc80',
                        'border-color': '#f57c00',
                        'border-style': 'dashed'
                    }
                },
                {
                    selector: 'node[highlighted]',
                    style: {
                        'background-color': '#bbdefb',
                        'border-width': 2,
                        'border-color': '#1976d2'
                    }
                },
                {
                    selector: 'edge',
                    style: {
                        'width': 2,
                        'line-color': '#999',
                        'target-arrow-color': '#999',
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'arrow-scale': 1.2
                    }
                }
            ],

            layout: layoutManager.getLayoutOptions()
        });

        // Update info on selection
        cy.on('select', 'node', function(evt) {
            const node = evt.target;
            const info = document.getElementById('info');
            info.textContent = `Selected: ${node.data('label')}`;
        });

        cy.on('unselect', 'node', function() {
            const info = document.getElementById('info');
            info.textContent = '';
        });

        // Control functions
        function fitGraph() {
            cy.fit(undefined, 50);
        }

        function resetZoom() {
            cy.zoom(1);
            cy.center();
        }

        function centerGraph() {
            cy.center();
        }

        function exportPNG() {
            const png = cy.png({ full: true, scale: 2 });
            const link = document.createElement('a');
            link.download = 'dependency-graph.png';
            link.href = png;
            link.click();
        }

        // ===== Module Selector Class =====

        class ModuleSelector {
            constructor(containerId, allModules, onChange) {
                this.container = document.getElementById(containerId);
                this.allModules = allModules;
                this.selected = new Set();
                this.onChange = onChange;
            }

            render() {
                const chips = Array.from(this.selected)
                    .sort()
                    .map(m => `<span class="module-chip">${m} <span class="remove" data-module="${m}">×</span></span>`)
                    .join('');
                this.container.innerHTML = chips;

                // Add remove handlers
                this.container.querySelectorAll('.remove').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.removeModule(btn.dataset.module);
                    });
                });
            }

            addModule(moduleId) {
                this.selected.add(moduleId);
                this.render();
                this.onChange(this.selected);
            }

            removeModule(moduleId) {
                this.selected.delete(moduleId);
                this.render();
                this.onChange(this.selected);
            }

            clear() {
                this.selected.clear();
                this.render();
            }
        }

        // ===== Initialize UI After Cytoscape is Ready =====

        // Get all module names for selectors
        const allModuleNames = cy.nodes().map(n => n.id()).sort();

        // Initialize module selectors
        const upstreamSelector = new ModuleSelector('upstream-chips', allModuleNames, (selected) => {
            filterState.upstreamRoots = selected;
        });

        const downstreamSelector = new ModuleSelector('downstream-chips', allModuleNames, (selected) => {
            filterState.downstreamRoots = selected;
        });

        upstreamSelector.render();
        downstreamSelector.render();

        // ===== Filter Control Event Handlers =====

        // Checkbox handlers
        document.getElementById('filter-orphans').addEventListener('change', (e) => {
            filterState.showOrphans = e.target.checked;
        });

        document.getElementById('filter-namespaces').addEventListener('change', (e) => {
            filterState.showNamespaces = e.target.checked;
        });

        document.getElementById('filter-highlighted-only').addEventListener('change', (e) => {
            filterState.highlightedOnly = e.target.checked;
        });

        // Distance slider with debounce
        let distanceTimeout;
        document.getElementById('distance-slider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('distance-display').textContent =
                value === 0 ? 'All Distances' : `Distance ≤ ${value}`;

            clearTimeout(distanceTimeout);
            distanceTimeout = setTimeout(() => {
                filterState.maxDistance = value === 0 ? null : value;
            }, 300);
        });

        // Exclude patterns input with debounce
        let patternTimeout;
        document.getElementById('exclude-patterns').addEventListener('input', (e) => {
            clearTimeout(patternTimeout);
            patternTimeout = setTimeout(() => {
                const value = e.target.value.trim();
                if (value) {
                    filterState.excludePatterns = value.split(',').map(p => p.trim()).filter(p => p);
                } else {
                    filterState.excludePatterns = [];
                }
            }, 300);
        });

        // Add module buttons - show simple prompt for now
        document.getElementById('add-upstream').addEventListener('click', () => {
            const moduleName = prompt('Enter module name:');
            if (moduleName && cy.getElementById(moduleName).length > 0) {
                upstreamSelector.addModule(moduleName);
            } else if (moduleName) {
                alert('Module not found: ' + moduleName);
            }
        });

        document.getElementById('add-downstream').addEventListener('click', () => {
            const moduleName = prompt('Enter module name:');
            if (moduleName && cy.getElementById(moduleName).length > 0) {
                downstreamSelector.addModule(moduleName);
            } else if (moduleName) {
                alert('Module not found: ' + moduleName);
            }
        });

        // Reset filters button
        document.getElementById('reset-filters').addEventListener('click', () => {
            filterState.reset();
            upstreamSelector.clear();
            downstreamSelector.clear();

            // Reset UI controls
            document.getElementById('filter-orphans').checked = true;
            document.getElementById('filter-namespaces').checked = true;
            document.getElementById('filter-highlighted-only').checked = false;
            document.getElementById('distance-slider').value = 0;
            document.getElementById('distance-display').textContent = 'All Distances';
            document.getElementById('exclude-patterns').value = '';

            // Show all nodes and edges
            cy.elements().style('display', 'element');

            // Reset to original layout
            layoutManager.setLayout('dagre');
            document.getElementById('layout-select').value = 'dagre';
            applyCurrentLayout(true);
        });

        // Apply filters button
        document.getElementById('apply-filters').addEventListener('click', () => {
            applyFilters();
        });

        // ===== Context Menu for Nodes =====

        let contextMenu = null;

        // Remove any existing context menu
        function removeContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        // Right-click on node
        cy.on('cxttap', 'node', function(event) {
            const node = event.target;
            const nodeId = node.id();

            removeContextMenu();

            // Create context menu
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.style.left = event.originalEvent.pageX + 'px';
            contextMenu.style.top = event.originalEvent.pageY + 'px';

            const isInUpstream = filterState.upstreamRoots.has(nodeId);
            const isInDownstream = filterState.downstreamRoots.has(nodeId);

            contextMenu.innerHTML = `
                <div class="menu-item" data-action="add-upstream"${isInUpstream ? ' style="opacity:0.5"' : ''}>Add to Upstream</div>
                <div class="menu-item" data-action="add-downstream"${isInDownstream ? ' style="opacity:0.5"' : ''}>Add to Downstream</div>
                ${isInUpstream ? '<div class="menu-item" data-action="remove-upstream">Remove from Upstream</div>' : ''}
                ${isInDownstream ? '<div class="menu-item" data-action="remove-downstream">Remove from Downstream</div>' : ''}
            `;

            document.body.appendChild(contextMenu);

            // Handle menu clicks
            contextMenu.addEventListener('click', (e) => {
                const action = e.target.dataset.action;

                if (action === 'add-upstream' && !isInUpstream) {
                    upstreamSelector.addModule(nodeId);
                } else if (action === 'add-downstream' && !isInDownstream) {
                    downstreamSelector.addModule(nodeId);
                } else if (action === 'remove-upstream') {
                    upstreamSelector.removeModule(nodeId);
                } else if (action === 'remove-downstream') {
                    downstreamSelector.removeModule(nodeId);
                }

                removeContextMenu();
            });

            // Remove menu on outside click
            setTimeout(() => {
                document.addEventListener('click', removeContextMenu, { once: true });
            }, 10);
        });

        // Initial fit
        setTimeout(() => {
            cy.fit(undefined, 50);
        }, 100);
    </script>
</body>
</html>
